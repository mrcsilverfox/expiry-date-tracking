# App

![coverage][coverage_badge]
[![style: very good analysis][very_good_analysis_badge]][very_good_analysis_link]
[![License: MIT][license_badge]][license_link]

Generated by the [Very Good CLI][very_good_cli_link] ü§ñ

A Very Good Project created by Very Good CLI.

---

## Getting Started üöÄ

This project contains 3 flavors:

- development
- staging
- production

To run the desired flavor either use the launch configuration in VSCode/Android Studio or use the following commands:

```sh
# Development
$ flutter run --flavor development --target lib/main_development.dart

# Staging
$ flutter run --flavor staging --target lib/main_staging.dart

# Production
$ flutter run --flavor production --target lib/main_production.dart
```

_\*App works on iOS, Android, Web, and Windows._

---

## Running Tests üß™

To run all unit and widget tests use the following command:

```sh
$ flutter test --coverage --test-randomize-ordering-seed random
```

To view the generated coverage report you can use [lcov](https://github.com/linux-test-project/lcov).

```sh
# Generate Coverage Report
$ genhtml coverage/lcov.info -o coverage/

# Open Coverage Report
$ open coverage/index.html
```

---

## Working with Translations üåê

This project relies on [flutter_localizations][flutter_localizations_link] and follows the [official internationalization guide for Flutter][internationalization_link].

### Adding Strings

1. To add a new localizable string, open the `app_en.arb` file at `lib/l10n/arb/app_en.arb`.

```arb
{
    "@@locale": "en",
    "counterAppBarTitle": "Counter",
    "@counterAppBarTitle": {
        "description": "Text shown in the AppBar of the Counter Page"
    }
}
```

2. Then add a new key/value and description

```arb
{
    "@@locale": "en",
    "counterAppBarTitle": "Counter",
    "@counterAppBarTitle": {
        "description": "Text shown in the AppBar of the Counter Page"
    },
    "helloWorld": "Hello World",
    "@helloWorld": {
        "description": "Hello World Text"
    }
}
```

3. Use the new string

```dart
import 'package:app/l10n/l10n.dart';

@override
Widget build(BuildContext context) {
  final l10n = context.l10n;
  return Text(l10n.helloWorld);
}
```

### Adding Supported Locales

Update the `CFBundleLocalizations` array in the `Info.plist` at `ios/Runner/Info.plist` to include the new locale.

```xml
    ...

    <key>CFBundleLocalizations</key>
	<array>
		<string>en</string>
		<string>es</string>
	</array>

    ...
```

### Adding Translations

1. For each supported locale, add a new ARB file in `lib/l10n/arb`.

```
‚îú‚îÄ‚îÄ l10n
‚îÇ   ‚îú‚îÄ‚îÄ arb
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app_en.arb
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ app_es.arb
```

2. Add the translated strings to each `.arb` file:

`app_en.arb`

```arb
{
    "@@locale": "en",
    "counterAppBarTitle": "Counter",
    "@counterAppBarTitle": {
        "description": "Text shown in the AppBar of the Counter Page"
    }
}
```

`app_es.arb`

```arb
{
    "@@locale": "es",
    "counterAppBarTitle": "Contador",
    "@counterAppBarTitle": {
        "description": "Texto mostrado en la AppBar de la p√°gina del contador"
    }
}
```

[coverage_badge]: coverage_badge.svg
[flutter_localizations_link]: https://api.flutter.dev/flutter/flutter_localizations/flutter_localizations-library.html
[internationalization_link]: https://flutter.dev/docs/development/accessibility-and-localization/internationalization
[license_badge]: https://img.shields.io/badge/license-MIT-blue.svg
[license_link]: https://opensource.org/licenses/MIT
[very_good_analysis_badge]: https://img.shields.io/badge/style-very_good_analysis-B22C89.svg
[very_good_analysis_link]: https://pub.dev/packages/very_good_analysis
[very_good_cli_link]: https://github.com/VeryGoodOpenSource/very_good_cli


## Docs
The app folder contains only the bloc and view (the presentation layer).
The core functionality are defined and implemented inside the packages folder. 

Others funcionalities use the clean architecture structure. (data, domain, view). 

### Core components
#### Package open_food_facts_api
We use the open food facts api to fetch the scanned product. We use the barcode to fetch the product. In the future we will can use own APIs, so is important to organize the code. 

The package `open_food_facts_api` contains the client. It allows to fetch a product from the barcode. It return an open food facts product object. 

We have to refactor the code: we'll have a package `product_api_client`. This packages is in charge of fetch the product from a barcode. It is not the same produt user adds in his pantry. 

Now the used client is `open_food_facts_client`, the client use the open food facts api.

#### Package open_food_facts_api_repository
The package `open_food_facts_api_repository` contains our Product model. This allows us to be decoupled with the open api product implementation. The repo use an _product_api_client_ to fetch the product and returns our product model. The model contains name, brand name and images.

#### Package products_api
The package `products_api` contains our data source. It is charge of manipulating the products entity. It defines simple CRUD operations, the domain product entity and the data product model. It will be used by the `products_repository`. 

The only one implementation of products_api now is `memory_products_api`. It stores products in memory. When the app is restarted, all products will be removed.

Next implementations are: `sql_products_api` and `remote_products_api`. The first allows the user to store prodcuts in a local db. The letter stores the products in the cloud. 

All this _api_ implements the `ProductsApi`.

#### Package products_repository
The package `products_repository` uses the `products_api` to retrive products, to add, edit and modify user's products. 
In this case the repository is not an interface, but it is a concrete class. 

```
food_api_client (abstract)
    - open_food_facts_client (concrete)
    - own_server_client (concrete) -- future.
```
```
open_food_facts_api_repository use an _food_api_client_ to get the products from a barcode 
    - data:
        - data_source: defines open_food_facts_client (concrete) and own_server_client (concrete)
        - models: extends domain models
        - repository: extends domain repository and use data_source    
    - domain:
        - models (concrete)
        - repositories (abstract)
        - use_cases: uses repositories 
```
```
products_api (abstract)
    - sql_products_api (concrete)
    - remote_products_api (concrete) 
```
Question: who defines the data model? _products_api_ or _products_repository_
```
products_repository
    - data:
        - data_source: defines sql_products_api (concrete) and remote_products_api (concrete)
        - models: extends domain models
        - repository: extends domain repository and use data_source    
    - domain:
        - models (concrete)
        - repositories (abstract)
        - use_cases: uses repositories 
```
### App
